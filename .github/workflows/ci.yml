name: CI - Tests unitaires + Perf (k6) + KPI

on:
  push:
    branches: [ "main", "tb_ci_cd" ]
  pull_request:

env:
  # Variables d'authentification
  SECRET_KEY: "test-secret-key-for-ci-only"
  ALGORITHM: "HS256"
  ACCESS_TOKEN_EXPIRE_MINUTES: "30"
  USER: "admin"
  PASSWORD: "Admin123!"

  # Configuration base de données
  DATABASE: "digicheese"
  MYSQL_ROOT_PASSWORD: "securepassword"
  DB_USER: "admin"
  DB_PASSWORD: "Admin123!"
  DB_HOST: "db"
  DB_PORT: "3306"
  DB_NAME: "digicheese"
  PORT_DB_VISUALISATION: "3307"

jobs:
  unit-tests:
    name: Unit tests (pytest in Docker)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Création du fichier .env pour Docker Compose
      # Les variables d'environnement doivent être disponibles pour les conteneurs
      - name: Create .env file for Docker Compose
        run: |
          cat > .env << EOF
          USER=admin
          PASSWORD=Admin123!
          DATABASE=digicheese
          PORT_DB_VISUALISATION=3307
          MYSQL_ROOT_PASSWORD=securepassword
          DB_USER=admin
          DB_PASSWORD=Admin123!
          DB_HOST=db
          DB_PORT=3306
          DB_NAME=digicheese
          SECRET_KEY=test-secret-key-for-ci-only
          ALGORITHM=HS256
          ACCESS_TOKEN_EXPIRE_MINUTES=30
          SEED_DB=false
          SEED_ADMIN=false
          ADMIN_EMAIL=admin@digicheese.com
          ADMIN_PASSWORD=Admin123!
          ADMIN_NOM=Root
          ADMIN_PRENOM=Admin
          SEED_USERS=false
          SEED_COMMUNES=false
          SEED_CLIENTS=false
          SEED_ADRESSES=false
          SEED_NB_OBJETS=20
          SEED_NB_COMMUNES=50
          SEED_NB_CLIENTS=30
          SEED_NB_ADRESSES=60
          EOF

      # Démarrage de la base de données MariaDB
      - name: Start database
        run: |
          docker compose up -d db
          
          # Attente de la disponibilité de MariaDB (timeout: 120 secondes)
          for i in {1..60}; do
            if docker compose exec -T db mysqladmin ping -h localhost -u admin -pAdmin123! --silent 2>/dev/null; then
              echo "MariaDB ready after $i attempts"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "MariaDB startup timeout"
              docker compose logs db
              exit 1
            fi
            sleep 2
          done
          
          # Délai supplémentaire pour stabilisation
          sleep 10

      # Démarrage de l'application FastAPI
      - name: Start FastAPI application
        run: |
          docker compose up -d --build fastapi
          sleep 10
          docker compose ps
          docker compose logs fastapi

      # Vérification de la disponibilité de l'API
      # L'API doit répondre sur http://localhost:8000 (port hôte mappé au port 80 du conteneur)
      - name: Wait for FastAPI to be ready
        run: |
          # Vérification du statut du conteneur
          for i in {1..30}; do
            if docker compose ps fastapi | grep -q "Up"; then
              echo "FastAPI container is running"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "FastAPI container failed to start"
              exit 1
            fi
            sleep 2
          done
          
          # Vérification de la disponibilité de l'endpoint /docs (timeout: 180 secondes)
          for i in {1..60}; do
            if curl -sf http://localhost:8000/docs > /dev/null 2>&1; then
              echo "FastAPI is responding on http://localhost:8000"
              exit 0
            fi
            
            if ! docker compose ps fastapi | grep -q "Up"; then
              echo "FastAPI container stopped unexpectedly"
              docker compose logs fastapi
              exit 1
            fi
            
            sleep 3
          done
          
          # Si l'API ne répond pas après le timeout, afficher les logs et échouer
          echo "FastAPI failed to become ready"
          docker compose ps
          docker compose logs fastapi
          docker compose logs db
          exit 1

      # Test de la connexion à la base de données depuis le conteneur FastAPI
      - name: Verify database connection
        run: |
          docker compose exec -T fastapi python -c "
          from api.database import engine
          try:
              with engine.connect() as conn:
                  print('Database connection successful')
          except Exception as e:
              print(f'Database connection failed: {e}')
              exit(1)
          " || {
            docker compose logs fastapi
            docker compose logs db
            exit 1
          }

      # Installation des dépendances de test dans le conteneur
      - name: Install test dependencies
        run: |
          docker compose exec -T fastapi pip install pytest pytest-cov

      # Exécution des tests unitaires avec couverture de code
      - name: Run pytest
        run: |
          mkdir -p reports
          docker compose exec -T fastapi pytest -v \
            --junitxml=/code/reports/pytest-junit.xml \
            --cov=api \
            --cov-report=xml:/code/reports/coverage.xml \
            --cov-report=term \
            --cov-report=html:/code/reports/htmlcov

      # Copie des rapports de test depuis le conteneur vers l'hôte
      - name: Copy test reports
        if: always()
        run: |
          container_id=$(docker compose ps -q fastapi)
          if [ -n "$container_id" ]; then
            docker cp ${container_id}:/code/reports ./reports 2>/dev/null || true
          fi

      # Upload des rapports de test en tant qu'artefacts GitHub
      - name: Upload test reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-reports
          path: reports/
          retention-days: 30
          if-no-files-found: warn

      - name: Upload coverage report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: reports/htmlcov/
          retention-days: 30
          if-no-files-found: warn

      # Commentaire automatique de la couverture sur les Pull Requests
      - name: Comment PR with coverage
        if: github.event_name == 'pull_request' && hashFiles('reports/coverage.xml') != ''
        uses: orgoro/coverage@v3.1
        with:
          coverageFile: reports/coverage.xml
          token: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      # Affichage des logs en cas d'échec
      - name: Display logs on failure
        if: failure()
        run: |
          echo "=== FastAPI Logs ==="
          docker compose logs fastapi --tail=300
          echo ""
          echo "=== MariaDB Logs ==="
          docker compose logs db --tail=100
          echo ""
          echo "=== Container Status ==="
          docker compose ps

      # Nettoyage des conteneurs et volumes
      - name: Cleanup
        if: always()
        run: |
          docker compose down -v


  perf-tests:
    name: Performance tests (k6) + KPI report
    runs-on: ubuntu-latest
    needs: unit-tests

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Configuration avec seeding activé pour les tests de performance
      - name: Create .env file for Docker Compose
        run: |
          cat > .env << EOF
          USER=admin
          PASSWORD=Admin123!
          DATABASE=digicheese
          PORT_DB_VISUALISATION=3307
          MYSQL_ROOT_PASSWORD=securepassword
          DB_USER=admin
          DB_PASSWORD=Admin123!
          DB_HOST=db
          DB_PORT=3306
          DB_NAME=digicheese
          SECRET_KEY=test-secret-key-for-ci-only
          ALGORITHM=HS256
          ACCESS_TOKEN_EXPIRE_MINUTES=30
          SEED_DB=true
          SEED_ADMIN=true
          ADMIN_EMAIL=admin@digicheese.com
          ADMIN_PASSWORD=Admin123!
          ADMIN_NOM=Root
          ADMIN_PRENOM=Admin
          SEED_USERS=true
          SEED_COMMUNES=true
          SEED_CLIENTS=true
          SEED_ADRESSES=true
          SEED_NB_OBJETS=20
          SEED_NB_COMMUNES=50
          SEED_NB_CLIENTS=30
          SEED_NB_ADRESSES=60
          EOF

      # Démarrage de la base de données
      - name: Start database with seeding
        run: |
          docker compose up -d db
          
          # Attente de la disponibilité de MariaDB
          for i in {1..60}; do
            if docker compose exec -T db mysqladmin ping -h localhost -u admin -pAdmin123! --silent 2>/dev/null; then
              echo "MariaDB ready after $i attempts"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "MariaDB startup timeout"
              docker compose logs db
              exit 1
            fi
            sleep 2
          done
          
          sleep 10

      # Démarrage de FastAPI avec données de test
      - name: Start FastAPI with seeding
        run: |
          docker compose up -d --build fastapi
          sleep 15
          docker compose ps
          docker compose logs fastapi --tail=50

      # Vérification de la disponibilité de l'API (timeout étendu pour le seeding)
      - name: Wait for API to be ready
        run: |
          for i in {1..120}; do
            if ! docker compose ps fastapi | grep -q "Up"; then
              echo "FastAPI container stopped"
              docker compose logs fastapi
              exit 1
            fi
            
            if curl -sf http://localhost:8000/docs > /dev/null 2>&1; then
              echo "API ready after $i attempts"
              exit 0
            fi
            
            # Affichage périodique des logs pour le suivi
            if [ $((i % 20)) -eq 0 ]; then
              docker compose logs fastapi --tail=20
            fi
            
            sleep 3
          done
          
          echo "API failed to become ready"
          docker compose ps
          docker compose logs fastapi --tail=200
          docker compose logs db --tail=100
          exit 1

      # Test de base des endpoints de l'API
      - name: Test API endpoints
        run: |
          echo "Testing /docs endpoint:"
          curl -v http://localhost:8000/docs 2>&1 | head -30
          
          echo "Testing /api/v1 endpoint:"
          curl -v http://localhost:8000/api/v1/ 2>&1 | head -20 || echo "Endpoint may not exist"

      # Préparation des répertoires pour les résultats
      - name: Prepare performance test directories
        run: |
          mkdir -p performance/results reports
          chmod -R 777 performance/results reports

      # Exécution des tests de performance avec k6
      # - Baseline (10 VUs): doit passer, bloque le build en cas d'échec
      # - Load test (50 VUs): informatif, ne bloque pas le build
      # - Stress test (100 VUs): informatif, ne bloque pas le build
      - name: Run k6 performance tests
        run: |
          run_k6_test() {
            local vus=$1
            local duration=$2
            local label=$3
            local enforce_thresholds=$4
            
            echo ""
            echo "=========================================="
            echo "Running k6 with ${vus} VUs (${label})"
            echo "=========================================="
            
            docker run --rm --network host \
              -v "${PWD}:/work" -w /work \
              grafana/k6 run performance/test.js \
              --vus ${vus} \
              --duration ${duration} \
              -e BASE_URL="http://localhost:8000" \
              -e API_PREFIX="/api/v1" \
              -e EMAIL="admin@digicheese.com" \
              -e PASSWORD="Admin123!" \
              --out json=performance/results/k6_${vus}.json \
              --summary-export=performance/results/summary_${vus}.json || {
                
                local exit_code=$?
                
                # Exit code 99 = dépassement de seuils de performance
                # Exit code 0 = succès
                # Autres codes = erreurs réelles (connexion, timeout, etc.)
                if [ $exit_code -eq 99 ]; then
                  if [ "$enforce_thresholds" = "true" ]; then
                    echo "Performance thresholds exceeded (BLOCKING)"
                    return 99
                  else
                    echo "Performance thresholds exceeded (WARNING - non-blocking)"
                    return 0
                  fi
                else
                  echo "Test failed with exit code $exit_code"
                  return $exit_code
                fi
              }
            
            echo "Test completed successfully"
          }
          
          # Test baseline (10 VUs) - bloque en cas d'échec
          run_k6_test 10 30s "baseline" true
          
          # Test de charge standard (50 VUs) - informatif uniquement
          run_k6_test 50 30s "standard load" false || true
          
          # Test de stress (100 VUs) - informatif uniquement
          run_k6_test 100 30s "stress test" false || true

      # Configuration de Python pour la génération de rapports
      - name: Setup Python for report generation
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # Installation des dépendances et génération du rapport de performance
      - name: Generate performance report
        run: |
          pip install --upgrade pip
          pip install pandas tabulate 2>/dev/null || true
          
          # Fonction pour créer un rapport par défaut si le parser n'existe pas
          create_fallback_report() {
            cat > reports/REPORT.md << 'EOF'
          # Performance Test Results
          
          Performance tests completed successfully.
          
          ## Test Scenarios Executed
          - Baseline (10 VUs)
          - Load test (50 VUs)
          - Stress test (100 VUs)
          
          ## Detailed Results
          Detailed JSON results are available in the artifacts.
          Download the `perf-reports` artifact to view complete metrics.
          
          ## Next Steps
          1. Review detailed k6 JSON files in artifacts
          2. Analyze response times and throughput
          3. Compare against your SLA requirements
          EOF
          }
          
          # Utilisation du parser personnalisé si disponible
          if [ -f "performance/ci/parse_k6.py" ]; then
            python performance/ci/parse_k6.py \
              --input performance/results \
              --output reports || create_fallback_report
          else
            create_fallback_report
          fi

      # Affichage du rapport généré
      - name: Display generated report
        if: always()
        run: |
          if [ -f "reports/REPORT.md" ]; then
            echo "=== Performance Report ==="
            cat reports/REPORT.md
            echo "==================================="
          fi

      # Commentaire automatique avec les résultats de performance sur les Pull Requests
      - name: Comment PR with performance results
        if: github.event_name == 'pull_request' && hashFiles('reports/REPORT.md') != ''
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          path: reports/REPORT.md
          header: performance-kpi
        continue-on-error: true

      # Upload des artefacts de performance
      - name: Upload performance artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: perf-reports
          path: |
            performance/results/
            reports/
          retention-days: 30

      # Affichage des logs en cas d'échec
      - name: Display logs on failure
        if: failure()
        run: |
          echo "=== FastAPI Logs ==="
          docker compose logs fastapi --tail=300
          echo ""
          echo "=== MariaDB Logs ==="
          docker compose logs db --tail=100
          echo ""
          echo "=== Container Status ==="
          docker compose ps

      # Nettoyage des conteneurs et volumes
      - name: Cleanup
        if: always()
        run: |
          docker compose down -v
          docker system prune -f || true